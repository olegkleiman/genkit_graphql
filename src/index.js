import { genkit } from 'genkit';
import fs from 'fs';
import { ApolloClient, gql, HttpLink, InMemoryCache } from "@apollo/client/core/index.js"; // Import directly from core
import { googleAI, gemini25FlashPreview0417} from '@genkit-ai/googleai';
import { startFlowServer, expressHandler } from '@genkit-ai/express';

import express from 'express';
import dotenv from 'dotenv';
dotenv.config();
import { z } from 'zod';
import { jwtDecode } from "jwt-decode";

const _googleAI = googleAI({ apiKey: process.env.GOOGLE_API_KEY });
const ai = genkit({
    plugins: [_googleAI],
    promptDir: './llm_prompts',
    model: gemini25FlashPreview0417,
    enableTracingAndMetrics: true 
});

const graphql_endpoint = process.env.GRAPHQL_URL;

export const executeGraphQL = ai.defineTool({
        name: "executedGraphQL",
        description: "execute any GraphQL query generated by LLM",
        inputSchema: z.object({
            query: z.string(),
        })
    }, 
    async (input, { context }) => {

        try {

            const httpLink = new HttpLink({ 
                uri: graphql_endpoint, 
                fetch,
                headers: { 
                    authorization: `Bearer ${context.access_token}`
                }   
            });
            const apolloClient = new ApolloClient({
                link: httpLink,
                cache: new InMemoryCache(),
            });

            if( input.query ) {
                const gqlQuery = gql`
                    ${input.query}
                `;

                const graphql_result = await apolloClient.query({
                    query: gqlQuery,
                });
                const me = graphql_result.data.me;
                const [topKey, connectionKey] = Object.keys(me); // __typeName and connectionName are returned
                const connection = me[connectionKey];
                const edges = connection?.edges || []

                if( Array.isArray(edges) ) {
                
                    const nodes = edges.map( (edge) => {
                        return edge.node
                    })
                    return nodes;
                } else {
                    return connection;
                }
            }

            
        } catch(error) {
            return `GraphQL query "${input}" execution failed. Error: ${error.message}`
        }     
    }  
);

export const toolsFlow = ai.defineFlow(
    {
        name: "ToolsFlow",
        inputSchema: z.string(),
        // outputSchema: z.string(),
    },
    async (flowInput, {context}) => {
        const prompt = ai.prompt('graphql_agent'); // '.prompt' extension will be added automatically

        const validationRequestBody = {
            clientId: process.env.CLIENT_ID
        }

        const token_validation_url = process.env.TOKEN_VALIDATION_URL;
        const validation_resp = await fetch(token_validation_url, {
            method: 'POST',
            body: JSON.stringify(validationRequestBody),
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + context.access_token 
            }
        })
        if( !validation_resp.ok ) {
            const errorJson = await validation_resp.json()
            const errorMessage = errorJson.developerMessage;
            throw new Error(errorMessage);
        }

        const schemaSDL = fs.readFileSync('./llm_prompts/schema.graphql', 'utf-8');

        const generateOptions = {
            system: `
                You are a helpful assistant that understand the following GraphQL schema and provide the information about the public events defined in this schema.
                Schema:
                ${schemaSDL}

                You must help the user generate GraphQL queries based on this schema. Answer only with the stringified query, omit other text.
                `,
            prompt:  "Generate the GraphQL query based on the provided schema and the user input, and pass the generated query to the function 'executedGraphQL'",
            // schema: z.string(), // or use structured if you're returning parsed data
            tools: [executeGraphQL],
        }

        // generate a response
        const llmResponse =  await ai.generate(
            generateOptions,
            context
        );

        const toolRequests = llmResponse.toolRequests;

        if( toolRequests.length == 0 ) {
            console.log("No tool requests found in LLM esponse.");
            return llmResponse;
        }

        const gqlQuery = gql`
            ${llmResponse.query}
        `;

        const graphql_result = await apolloClient.query({
            query: gqlQuery,
        });

        return llmResponse;
    }
);

const port = process.env.PORT ? Number(process.env.PORT) : undefined;

const app = express();
app.use(express.json());

app.post('/toolsFlow', async(req, res) => {
    const headers = req.headers;
    const access_token = headers?.authorization?.split(' ')[1];
    const decoded = jwtDecode(access_token);
    const userId = decoded["signInNames.citizenId"];
    const result = await toolsFlow(req.body.data, {
                                context: { 
                                    headers,
                                    access_token,
                                    userId
                                } 
                            }
                    );
    res.json(result);
})

app.listen(port, () => {
    console.log(`Server is running on port ${port}`);
});


// startFlowServer({
//     flows: [toolsFlow],
//     port: port,
// });