import { genkit } from 'genkit';
import fs, { link } from 'fs';
import { ApolloClient, gql, HttpLink, InMemoryCache } from "@apollo/client/core/index.js"; // Import directly from core
import { googleAI, gemini25FlashPreview0417} from '@genkit-ai/googleai';
// import { startFlowServer, expressHandler } from '@genkit-ai/express';

import express from 'express';
import dotenv from 'dotenv';
dotenv.config();
import { z } from 'zod';
import { jwtDecode } from "jwt-decode";

const _googleAI = googleAI({ apiKey: process.env.GOOGLE_API_KEY });
const ai = genkit({
    plugins: [_googleAI],
    promptDir: './llm_prompts', // scan this directory and register any .prompt files found.
    model: gemini25FlashPreview0417,
    enableTracingAndMetrics: true 
});

const graphql_endpoint = process.env.GRAPHQL_URL;

// const welcome_prompt = ai.definePrompt({
//     name: "sample",
//     model: "googleai/gemini-2.5-flash",
//     input: {
//       schema: z.object({
//         language: z.string(),
//       }),
//     },
//     prompt: "You are the world\'s most welcoming AI assistant. Greet the user in {{language}} and offer your assistance."
// });

// const graphQL_agent_prompt = ai.definePrompt({
//     name: "graphql_agent",
//     input: {
//       schema: z.object({
//         schemaSDL: z.string(),
//       }),
//     },
//     prompt: `
//     You are a helpful assistant that understands the following GraphQL schema and provides the information about the properties and connections defined in this schema.
//     {{schemaSDL}}
//     You must help the user generate GraphQL queries based on this schema. Answer only with the stringified query, omit other text.`
// });

export const executeGraphQL = ai.defineTool({
        name: "executedGraphQL",
        description: "execute any GraphQL query generated by LLM",
        inputSchema: z.object({
            query: z.string(),
        }),
        outputSchema: z.array(
            z.object({
                name: z.string(),
                description: z.string().nullable().optional(),
                link: z.string().url().nullable().optional()
            })
        )
    },
    async (input, { context }) => {

        try {

            const httpLink = new HttpLink({ 
                uri: graphql_endpoint, 
                fetch,
                headers: { 
                    authorization: `Bearer ${context.access_token}`
                }   
            });
            const apolloClient = new ApolloClient({
                link: httpLink,
                cache: new InMemoryCache(),
            });

            if(input.query) {
                const gqlQuery = gql`${input.query}`;
                const graphql_result = await apolloClient.query({
                    query: gqlQuery,
                });
                if (!graphql_result.data || !graphql_result.data.me) {
                    console.log("Query did not return a 'me' object.");
                    return [];
                }

                const me = graphql_result.data.me;

                // Generalization

                // Find the first key on the 'me' object that isn't '__typename'.
                // This assumes the LLM generates a query with one main data field under 'me'.
                const dataKey = Object.keys(me).find(key => key !== '__typename');
                const resultData = me[dataKey];
                let items = [];

                // Check if the result is a GraphQL Connection (has 'edges').
                if (resultData && Array.isArray(resultData.edges)) {
                    items = resultData.edges.map(edge => edge.node).filter(node => node !== null); // Filter out null nodes
                }
                // Check if the result is a simple array.
                else if (Array.isArray(resultData)) {
                    items = resultData.filter(item => item !== null); // Filter out null items
                }

                // Now, map the extracted items to the desired output format.
                // This is more flexible and won't crash if a field is missing.
                return items.map(item => ({
                    // The LLM should be prompted to return a 'name' or 'title' field.
                    // We can look for common variations.
                    name: String(item.name || item.title || item.ticketNumber || item.accountNumber || 'N/A'),
                    description: item.description ? String(item.description) : null,
                    link: item.link ? String(item.link) : null,
                }));

                // End of generalization

                // const [_, connectionKey] = Object.keys(me); // __typeName and connectionName are returned
                // const connection = me[connectionKey];
                // const edges = connection?.edges || []

                // if( Array.isArray(edges) ) {
                
                //     const nodes = edges.map( (edge) => {
                //         return {
                //             name: edge.node.name,
                //             description: edge.node.description,
                //             link: edge.node.link
                //         }
                //     })
                //     return nodes;
                // } else {
                //     return [];
                // }
            }

            return [];

        } catch(error) {
            console.error(`GraphQL query "${input.query}" execution failed. Error: ${error.message}`);
            return [];
        }     
    }  
);

export const toolsFlow = ai.defineFlow(
    {
        name: "ToolsFlow",
        inputSchema: z.string(),
        // outputSchema: z.string(),
    },
    async (flowInput, {context}) => {

        const validationRequestBody = {
            clientId: process.env.CLIENT_ID
        }

        const token_validation_url = process.env.TOKEN_VALIDATION_URL;
        const validation_resp = await fetch(token_validation_url, {
            method: 'POST',
            body: JSON.stringify(validationRequestBody),
            headers: { 
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + context.access_token 
            }
        })
        if( !validation_resp.ok ) {
            const errorJson = await validation_resp.json()
            const errorMessage = errorJson.developerMessage;
            throw new Error(errorMessage);
        }

        const schemaSDL = fs.readFileSync('./llm_prompts/schema.graphql', 'utf-8');

        // Test

        // console.log(response.text);
        const graphQL_agent_prompt = ai.prompt('graphql_agent'); // '.prompt' extension will be added automatically
        let response = await graphQL_agent_prompt(
            {
                schemaSDL: schemaSDL,
                userInput: flowInput
            }
        )
        // const graphqlPrompt = promptTemplate({
        //     name: 'graphql_agent', // maps to ./llm_prompts/graphql_agent.prompt
        //     inputSchema: z.object({
        //         schemaSDL: z.string(),
        //         userInput: z.string(),
        //     }),
        // });
        // const prompt_with_vars = graphqlPrompt.withVariables({
        //     schemaSDL: 'type Query { events: [Event] }',
        //     userRequest: 'List all events',
        // });

        console.log(response.text);
        
        const rendered = await graphQL_agent_prompt.render(response);
        console.log(rendered.text);
        
        // End test

        

        const generateOptions = {
            system: `
                You are a helpful assistant that understands the following GraphQL schema and provides the information about the properties and connections defined in this schema.
                Schema:
                ${schemaSDL}

                You must help the user generate GraphQL queries based on this schema. Answer only with the stringified query, omit other text.
                `,
            prompt:  `Generate the GraphQL query based on the provided schema and the user input, and pass the generated query to the function 'executedGraphQL'
                User's input: ${flowInput}
                `,
            // messages: [...prompt],
            tools: [executeGraphQL],
        }

        // generate a response
        const llmResponse =  await ai.generate(
            generateOptions
            //context
        );

        const toolRequests = llmResponse.toolRequests();

        if( !toolRequests || toolRequests.length === 0 ) {
            console.log("No tool requests found in LLM response.");
            return llmResponse.text();
        } else {
            const results = await Promise.all(
                toolRequests.map(req => executeGraphQL(req.toolRequest.input))
            );
            return results.length > 0 ? results[0] : [];
        }

    }
);

const port = process.env.PORT ? Number(process.env.PORT) : undefined;

const app = express();
app.use(express.json());

app.post('/toolsFlow', async(req, res) => {
    const headers = req.headers;
    const access_token = headers?.authorization?.split(' ')[1];
    const decoded = jwtDecode(access_token);
    const userId = decoded["signInNames.citizenId"];
    const result = await toolsFlow(req.body.data, {
                                context: { 
                                    headers,
                                    access_token,
                                    userId
                                } 
                            }
                    );
    res.json(result);
})

app.listen(port, () => {
    console.log(`Server is running on port ${port}`);
});


// startFlowServer({
//     flows: [toolsFlow],
//     port: port,
// });